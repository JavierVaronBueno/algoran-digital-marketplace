#pragma version 10

smart_contracts.digitalmarketplace.contract.Digitalmarketplace.approval_program:
    intcblock 0 1 4
    bytecblock "asset_id" "unitary_price"
    callsub __puya_arc4_router__
    return


// smart_contracts.digitalmarketplace.contract.Digitalmarketplace.__puya_arc4_router__() -> uint64:
__puya_arc4_router__:
    // smart_contracts/digitalmarketplace/contract.py:29
    // class Digitalmarketplace(ARC4Contract):
    proto 0 1
    txn NumAppArgs
    bz __puya_arc4_router___after_if_else@10
    pushbytess 0x878cbb3d 0x1574535a 0xcc760037 0x9b55f84e 0x33b3499e // method "create_application(asset,uint64)void", method "opt_in_to_asset(pay)void", method "set_price(uint64)void", method "buy(uint64,pay)void", method "delete_application()void"
    txna ApplicationArgs 0
    match __puya_arc4_router___create_application_route@2 __puya_arc4_router___opt_in_to_asset_route@3 __puya_arc4_router___set_price_route@4 __puya_arc4_router___buy_route@5 __puya_arc4_router___delete_application_route@6
    intc_0 // 0
    retsub

__puya_arc4_router___create_application_route@2:
    // smart_contracts/digitalmarketplace/contract.py:41-42
    // # Creación del contrato o la aplicación Dapp
    // @arc4.abimethod(allow_actions=["NoOp"], create="require")
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    !
    assert // can only call when creating
    // smart_contracts/digitalmarketplace/contract.py:29
    // class Digitalmarketplace(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    txnas Assets
    txna ApplicationArgs 2
    btoi
    // smart_contracts/digitalmarketplace/contract.py:41-42
    // # Creación del contrato o la aplicación Dapp
    // @arc4.abimethod(allow_actions=["NoOp"], create="require")
    callsub create_application
    intc_1 // 1
    retsub

__puya_arc4_router___opt_in_to_asset_route@3:
    // smart_contracts/digitalmarketplace/contract.py:58-59
    // # Usuario vendedor enviará assets al contrato
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/digitalmarketplace/contract.py:29
    // class Digitalmarketplace(ARC4Contract):
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/digitalmarketplace/contract.py:58-59
    // # Usuario vendedor enviará assets al contrato
    // @arc4.abimethod
    callsub opt_in_to_asset
    intc_1 // 1
    retsub

__puya_arc4_router___set_price_route@4:
    // smart_contracts/digitalmarketplace/contract.py:94-95
    // # Usuario vendedor define el precio de venta de los assets
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/digitalmarketplace/contract.py:29
    // class Digitalmarketplace(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    // smart_contracts/digitalmarketplace/contract.py:94-95
    // # Usuario vendedor define el precio de venta de los assets
    // @arc4.abimethod
    callsub set_price
    intc_1 // 1
    retsub

__puya_arc4_router___buy_route@5:
    // smart_contracts/digitalmarketplace/contract.py:111-112
    // # Usuario comprador puede hacer la compra de n assets
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/digitalmarketplace/contract.py:29
    // class Digitalmarketplace(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/digitalmarketplace/contract.py:111-112
    // # Usuario comprador puede hacer la compra de n assets
    // @arc4.abimethod
    callsub buy
    intc_1 // 1
    retsub

__puya_arc4_router___delete_application_route@6:
    // smart_contracts/digitalmarketplace/contract.py:148-149
    // # Usuario vendedor puede reclamar las ganancias y assets sobrantes
    // @arc4.abimethod(allow_actions=["DeleteApplication"])
    txn OnCompletion
    pushint 5 // DeleteApplication
    ==
    assert // OnCompletion is not DeleteApplication
    txn ApplicationID
    assert // can only call when not creating
    callsub delete_application
    intc_1 // 1
    retsub

__puya_arc4_router___after_if_else@10:
    // smart_contracts/digitalmarketplace/contract.py:29
    // class Digitalmarketplace(ARC4Contract):
    intc_0 // 0
    retsub


// smart_contracts.digitalmarketplace.contract.Digitalmarketplace.create_application(asset_id: uint64, unitary_price: uint64) -> void:
create_application:
    // smart_contracts/digitalmarketplace/contract.py:41-43
    // # Creación del contrato o la aplicación Dapp
    // @arc4.abimethod(allow_actions=["NoOp"], create="require")
    // def create_application(self, asset_id: Asset, unitary_price: UInt64) -> None:
    proto 2 0
    // smart_contracts/digitalmarketplace/contract.py:53-54
    // # Guardar un número de Asset ID
    // self.asset_id = asset_id.id
    bytec_0 // "asset_id"
    frame_dig -2
    app_global_put
    // smart_contracts/digitalmarketplace/contract.py:55-56
    // # Guardar un precio unitario
    // self.unitary_price = unitary_price
    bytec_1 // "unitary_price"
    frame_dig -1
    app_global_put
    retsub


// smart_contracts.digitalmarketplace.contract.Digitalmarketplace.opt_in_to_asset(mbr_pay: uint64) -> void:
opt_in_to_asset:
    // smart_contracts/digitalmarketplace/contract.py:58-63
    // # Usuario vendedor enviará assets al contrato
    // @arc4.abimethod
    // def opt_in_to_asset(
    //     self,
    //     mbr_pay: gtxn.PaymentTransaction,  # Transacción de pago dentro de una transacción grupal o transacciones atómicas
    // ) -> None:
    proto 1 0
    // smart_contracts/digitalmarketplace/contract.py:75-76
    // # Verifica que el que envía sea el creador del contrato; esta acción solo la puede hacer el creador
    // assert Txn.sender == Global.creator_address
    txn Sender
    global CreatorAddress
    ==
    assert
    // smart_contracts/digitalmarketplace/contract.py:78-79
    // # Verifica que ya no se haya hecho opt-in
    // assert not Global.current_application_address.is_opted_in(Asset(self.asset_id))
    global CurrentApplicationAddress
    intc_0 // 0
    bytec_0 // "asset_id"
    app_global_get_ex
    assert // check self.asset_id exists
    asset_holding_get AssetBalance
    bury 1
    !
    assert
    // smart_contracts/digitalmarketplace/contract.py:81-82
    // # Verifica que el receptor del pago sea la aplicación
    // assert mbr_pay.receiver == Global.current_application_address
    frame_dig -1
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    assert
    // smart_contracts/digitalmarketplace/contract.py:84-85
    // # Verifica el balance mínimo de la aplicación
    // assert mbr_pay.amount == Global.min_balance + Global.asset_opt_in_min_balance
    frame_dig -1
    gtxns Amount
    global MinBalance
    global AssetOptInMinBalance
    +
    ==
    assert
    // smart_contracts/digitalmarketplace/contract.py:87-92
    // # Lógica de la transacción interna
    // itxn.AssetTransfer(
    //     xfer_asset=self.asset_id,  # Asset a enviar
    //     asset_receiver=Global.current_application_address,  # Quien recibe es la misma aplicación
    //     asset_amount=0,  # Al enviar cero tokens, se da permiso a la red para interactuar con ese asset
    // ).submit()
    itxn_begin
    // smart_contracts/digitalmarketplace/contract.py:89
    // xfer_asset=self.asset_id,  # Asset a enviar
    intc_0 // 0
    bytec_0 // "asset_id"
    app_global_get_ex
    assert // check self.asset_id exists
    // smart_contracts/digitalmarketplace/contract.py:90
    // asset_receiver=Global.current_application_address,  # Quien recibe es la misma aplicación
    global CurrentApplicationAddress
    // smart_contracts/digitalmarketplace/contract.py:91
    // asset_amount=0,  # Al enviar cero tokens, se da permiso a la red para interactuar con ese asset
    intc_0 // 0
    itxn_field AssetAmount
    itxn_field AssetReceiver
    itxn_field XferAsset
    // smart_contracts/digitalmarketplace/contract.py:87-88
    // # Lógica de la transacción interna
    // itxn.AssetTransfer(
    intc_2 // axfer
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/digitalmarketplace/contract.py:87-92
    // # Lógica de la transacción interna
    // itxn.AssetTransfer(
    //     xfer_asset=self.asset_id,  # Asset a enviar
    //     asset_receiver=Global.current_application_address,  # Quien recibe es la misma aplicación
    //     asset_amount=0,  # Al enviar cero tokens, se da permiso a la red para interactuar con ese asset
    // ).submit()
    itxn_submit
    retsub


// smart_contracts.digitalmarketplace.contract.Digitalmarketplace.set_price(unitary_price: uint64) -> void:
set_price:
    // smart_contracts/digitalmarketplace/contract.py:94-96
    // # Usuario vendedor define el precio de venta de los assets
    // @arc4.abimethod
    // def set_price(self, unitary_price: UInt64) -> None:
    proto 1 0
    // smart_contracts/digitalmarketplace/contract.py:106-107
    // # Verifica que el que modifica el precio sea el creador del contrato; esta acción solo la puede hacer el creador
    // assert Txn.sender == Global.creator_address
    txn Sender
    global CreatorAddress
    ==
    assert
    // smart_contracts/digitalmarketplace/contract.py:108-109
    // # Edita el precio unitario
    // self.unitary_price = unitary_price
    bytec_1 // "unitary_price"
    frame_dig -1
    app_global_put
    retsub


// smart_contracts.digitalmarketplace.contract.Digitalmarketplace.buy(quantity: uint64, buyer_txn: uint64) -> void:
buy:
    // smart_contracts/digitalmarketplace/contract.py:111-117
    // # Usuario comprador puede hacer la compra de n assets
    // @arc4.abimethod
    // def buy(
    //     self,
    //     quantity: UInt64,  # Cantidad de assets a comprar
    //     buyer_txn: gtxn.PaymentTransaction,  # Transacción de pago dentro de una transacción grupal o transacciones atómicas
    // ) -> None:
    proto 2 0
    // smart_contracts/digitalmarketplace/contract.py:129-130
    // # Verificar que el precio de venta sea diferente de cero
    // assert self.unitary_price != UInt64(0)
    intc_0 // 0
    bytec_1 // "unitary_price"
    app_global_get_ex
    assert // check self.unitary_price exists
    assert
    // smart_contracts/digitalmarketplace/contract.py:132-133
    // # Verificar que el que está enviando la transacción de pago sea el mismo que está llamando al método
    // assert buyer_txn.sender == Txn.sender
    frame_dig -1
    gtxns Sender
    txn Sender
    ==
    assert
    // smart_contracts/digitalmarketplace/contract.py:135-136
    // # Verificar que el pago que se está haciendo sea a la cuenta del contrato inteligente
    // assert buyer_txn.receiver == Global.current_application_address
    frame_dig -1
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    assert
    // smart_contracts/digitalmarketplace/contract.py:138-139
    // # Verificar el monto que se está pagando para comprar los assets
    // assert buyer_txn.amount == self.unitary_price * quantity
    frame_dig -1
    gtxns Amount
    intc_0 // 0
    bytec_1 // "unitary_price"
    app_global_get_ex
    assert // check self.unitary_price exists
    frame_dig -2
    *
    ==
    assert
    // smart_contracts/digitalmarketplace/contract.py:141-146
    // # Hacer que el contrato envíe la transacción interna de transferencia de assets
    // itxn.AssetTransfer(
    //     xfer_asset=self.asset_id,  # Asset a comprar
    //     asset_receiver=Txn.sender,  # El contrato a quien le va a enviar ese asset
    //     asset_amount=quantity,  # Monto a transferir
    // ).submit()
    itxn_begin
    // smart_contracts/digitalmarketplace/contract.py:143
    // xfer_asset=self.asset_id,  # Asset a comprar
    intc_0 // 0
    bytec_0 // "asset_id"
    app_global_get_ex
    assert // check self.asset_id exists
    // smart_contracts/digitalmarketplace/contract.py:144
    // asset_receiver=Txn.sender,  # El contrato a quien le va a enviar ese asset
    txn Sender
    frame_dig -2
    itxn_field AssetAmount
    itxn_field AssetReceiver
    itxn_field XferAsset
    // smart_contracts/digitalmarketplace/contract.py:141-142
    // # Hacer que el contrato envíe la transacción interna de transferencia de assets
    // itxn.AssetTransfer(
    intc_2 // axfer
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/digitalmarketplace/contract.py:141-146
    // # Hacer que el contrato envíe la transacción interna de transferencia de assets
    // itxn.AssetTransfer(
    //     xfer_asset=self.asset_id,  # Asset a comprar
    //     asset_receiver=Txn.sender,  # El contrato a quien le va a enviar ese asset
    //     asset_amount=quantity,  # Monto a transferir
    // ).submit()
    itxn_submit
    retsub


// smart_contracts.digitalmarketplace.contract.Digitalmarketplace.delete_application() -> void:
delete_application:
    // smart_contracts/digitalmarketplace/contract.py:148-150
    // # Usuario vendedor puede reclamar las ganancias y assets sobrantes
    // @arc4.abimethod(allow_actions=["DeleteApplication"])
    // def delete_application(self) -> None:
    proto 0 0
    // smart_contracts/digitalmarketplace/contract.py:161-162
    // # Verifica que el que elimina el contrato sea el creador del contrato; esta acción solo la puede hacer el creador
    // assert Txn.sender == Global.creator_address
    txn Sender
    global CreatorAddress
    ==
    assert
    // smart_contracts/digitalmarketplace/contract.py:164-170
    // # Reclamar el saldo de los productos
    // itxn.AssetTransfer(
    //     xfer_asset=self.asset_id,  # Asset a enviar al creador
    //     asset_receiver=Global.creator_address,  # Se le envía al creador
    //     asset_amount=0,  # Se le envía un monto de cero
    //     asset_close_to=Global.creator_address,  # Eliminamos el permiso de interactuar con el asset y enviamos el saldo al creador
    // ).submit()
    itxn_begin
    // smart_contracts/digitalmarketplace/contract.py:166
    // xfer_asset=self.asset_id,  # Asset a enviar al creador
    intc_0 // 0
    bytec_0 // "asset_id"
    app_global_get_ex
    assert // check self.asset_id exists
    // smart_contracts/digitalmarketplace/contract.py:167
    // asset_receiver=Global.creator_address,  # Se le envía al creador
    global CreatorAddress
    // smart_contracts/digitalmarketplace/contract.py:169
    // asset_close_to=Global.creator_address,  # Eliminamos el permiso de interactuar con el asset y enviamos el saldo al creador
    dup
    itxn_field AssetCloseTo
    // smart_contracts/digitalmarketplace/contract.py:168
    // asset_amount=0,  # Se le envía un monto de cero
    intc_0 // 0
    itxn_field AssetAmount
    itxn_field AssetReceiver
    itxn_field XferAsset
    // smart_contracts/digitalmarketplace/contract.py:164-165
    // # Reclamar el saldo de los productos
    // itxn.AssetTransfer(
    intc_2 // axfer
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/digitalmarketplace/contract.py:164-170
    // # Reclamar el saldo de los productos
    // itxn.AssetTransfer(
    //     xfer_asset=self.asset_id,  # Asset a enviar al creador
    //     asset_receiver=Global.creator_address,  # Se le envía al creador
    //     asset_amount=0,  # Se le envía un monto de cero
    //     asset_close_to=Global.creator_address,  # Eliminamos el permiso de interactuar con el asset y enviamos el saldo al creador
    // ).submit()
    itxn_submit
    // smart_contracts/digitalmarketplace/contract.py:172-177
    // # Reclamar la ganancia de Algos
    // itxn.Payment(
    //     receiver=Global.creator_address,  # Quien recibe es el creador
    //     amount=0,  # Monto a recuperar, cero
    //     close_remainder_to=Global.creator_address,  # Se envían los Algos de ganancias y el balance mínimo
    // ).submit()
    itxn_begin
    // smart_contracts/digitalmarketplace/contract.py:174
    // receiver=Global.creator_address,  # Quien recibe es el creador
    global CreatorAddress
    // smart_contracts/digitalmarketplace/contract.py:176
    // close_remainder_to=Global.creator_address,  # Se envían los Algos de ganancias y el balance mínimo
    dup
    itxn_field CloseRemainderTo
    // smart_contracts/digitalmarketplace/contract.py:175
    // amount=0,  # Monto a recuperar, cero
    intc_0 // 0
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/digitalmarketplace/contract.py:172-173
    // # Reclamar la ganancia de Algos
    // itxn.Payment(
    intc_1 // pay
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/digitalmarketplace/contract.py:172-177
    // # Reclamar la ganancia de Algos
    // itxn.Payment(
    //     receiver=Global.creator_address,  # Quien recibe es el creador
    //     amount=0,  # Monto a recuperar, cero
    //     close_remainder_to=Global.creator_address,  # Se envían los Algos de ganancias y el balance mínimo
    // ).submit()
    itxn_submit
    retsub
