#pragma version 10

smart_contracts.digitalmarketplace.contract.Digitalmarketplace.approval_program:
    intcblock 0 1 4
    bytecblock "asset_id" "unitary_price"
    callsub __puya_arc4_router__
    return


// smart_contracts.digitalmarketplace.contract.Digitalmarketplace.__puya_arc4_router__() -> uint64:
__puya_arc4_router__:
    // smart_contracts/digitalmarketplace/contract.py:4
    // class Digitalmarketplace(ARC4Contract):
    proto 0 1
    txn NumAppArgs
    bz __puya_arc4_router___after_if_else@10
    pushbytess 0x878cbb3d 0x1574535a 0xcc760037 0x9b55f84e 0x33b3499e // method "create_application(asset,uint64)void", method "opt_in_to_asset(pay)void", method "set_price(uint64)void", method "buy(uint64,pay)void", method "delete_application()void"
    txna ApplicationArgs 0
    match __puya_arc4_router___create_application_route@2 __puya_arc4_router___opt_in_to_asset_route@3 __puya_arc4_router___set_price_route@4 __puya_arc4_router___buy_route@5 __puya_arc4_router___delete_application_route@6
    intc_0 // 0
    retsub

__puya_arc4_router___create_application_route@2:
    // smart_contracts/digitalmarketplace/contract.py:19
    // @arc4.abimethod(allow_actions=["NoOp"], create="require")
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    !
    assert // can only call when creating
    // smart_contracts/digitalmarketplace/contract.py:4
    // class Digitalmarketplace(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    txnas Assets
    txna ApplicationArgs 2
    btoi
    // smart_contracts/digitalmarketplace/contract.py:19
    // @arc4.abimethod(allow_actions=["NoOp"], create="require")
    callsub create_application
    intc_1 // 1
    retsub

__puya_arc4_router___opt_in_to_asset_route@3:
    // smart_contracts/digitalmarketplace/contract.py:33
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/digitalmarketplace/contract.py:4
    // class Digitalmarketplace(ARC4Contract):
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/digitalmarketplace/contract.py:33
    // @arc4.abimethod
    callsub opt_in_to_asset
    intc_1 // 1
    retsub

__puya_arc4_router___set_price_route@4:
    // smart_contracts/digitalmarketplace/contract.py:68
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/digitalmarketplace/contract.py:4
    // class Digitalmarketplace(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    // smart_contracts/digitalmarketplace/contract.py:68
    // @arc4.abimethod
    callsub set_price
    intc_1 // 1
    retsub

__puya_arc4_router___buy_route@5:
    // smart_contracts/digitalmarketplace/contract.py:84
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/digitalmarketplace/contract.py:4
    // class Digitalmarketplace(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/digitalmarketplace/contract.py:84
    // @arc4.abimethod
    callsub buy
    intc_1 // 1
    retsub

__puya_arc4_router___delete_application_route@6:
    // smart_contracts/digitalmarketplace/contract.py:118
    // @arc4.abimethod(allow_actions=["DeleteApplication"])
    txn OnCompletion
    pushint 5 // DeleteApplication
    ==
    assert // OnCompletion is not DeleteApplication
    txn ApplicationID
    assert // can only call when not creating
    callsub delete_application
    intc_1 // 1
    retsub

__puya_arc4_router___after_if_else@10:
    // smart_contracts/digitalmarketplace/contract.py:4
    // class Digitalmarketplace(ARC4Contract):
    intc_0 // 0
    retsub


// smart_contracts.digitalmarketplace.contract.Digitalmarketplace.create_application(asset_id: uint64, unitary_price: uint64) -> void:
create_application:
    // smart_contracts/digitalmarketplace/contract.py:19-20
    // @arc4.abimethod(allow_actions=["NoOp"], create="require")
    // def create_application(self, asset_id: Asset, unitary_price: UInt64) -> None:
    proto 2 0
    // smart_contracts/digitalmarketplace/contract.py:28-29
    // # Store the asset ID
    // self.asset_id = asset_id.id
    bytec_0 // "asset_id"
    frame_dig -2
    app_global_put
    // smart_contracts/digitalmarketplace/contract.py:30-31
    // # Store the unitary price
    // self.unitary_price = unitary_price
    bytec_1 // "unitary_price"
    frame_dig -1
    app_global_put
    retsub


// smart_contracts.digitalmarketplace.contract.Digitalmarketplace.opt_in_to_asset(mbr_pay: uint64) -> void:
opt_in_to_asset:
    // smart_contracts/digitalmarketplace/contract.py:33-34
    // @arc4.abimethod
    // def opt_in_to_asset(self, mbr_pay: gtxn.PaymentTransaction) -> None:
    proto 1 0
    // smart_contracts/digitalmarketplace/contract.py:49-50
    // # Ensure only the creator can perform this action
    // assert Txn.sender == Global.creator_address
    txn Sender
    global CreatorAddress
    ==
    assert
    // smart_contracts/digitalmarketplace/contract.py:52-53
    // # Ensure the application is not already opted-in to the asset
    // assert not Global.current_application_address.is_opted_in(Asset(self.asset_id))
    global CurrentApplicationAddress
    intc_0 // 0
    bytec_0 // "asset_id"
    app_global_get_ex
    assert // check self.asset_id exists
    asset_holding_get AssetBalance
    bury 1
    !
    assert
    // smart_contracts/digitalmarketplace/contract.py:55-56
    // # Ensure the receiver of the payment is the application
    // assert mbr_pay.receiver == Global.current_application_address
    frame_dig -1
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    assert
    // smart_contracts/digitalmarketplace/contract.py:58-59
    // # Ensure the payment meets minimum balance requirements
    // assert mbr_pay.amount == Global.min_balance + Global.asset_opt_in_min_balance
    frame_dig -1
    gtxns Amount
    global MinBalance
    global AssetOptInMinBalance
    +
    ==
    assert
    // smart_contracts/digitalmarketplace/contract.py:61-66
    // # Perform the internal asset transfer for opting in
    // itxn.AssetTransfer(
    //     xfer_asset=self.asset_id,  # Asset to opt into
    //     asset_receiver=Global.current_application_address,  # Application receives the asset
    //     asset_amount=0,  # Zero tokens are sent, enabling opt-in
    // ).submit()
    itxn_begin
    // smart_contracts/digitalmarketplace/contract.py:63
    // xfer_asset=self.asset_id,  # Asset to opt into
    intc_0 // 0
    bytec_0 // "asset_id"
    app_global_get_ex
    assert // check self.asset_id exists
    // smart_contracts/digitalmarketplace/contract.py:64
    // asset_receiver=Global.current_application_address,  # Application receives the asset
    global CurrentApplicationAddress
    // smart_contracts/digitalmarketplace/contract.py:65
    // asset_amount=0,  # Zero tokens are sent, enabling opt-in
    intc_0 // 0
    itxn_field AssetAmount
    itxn_field AssetReceiver
    itxn_field XferAsset
    // smart_contracts/digitalmarketplace/contract.py:61-62
    // # Perform the internal asset transfer for opting in
    // itxn.AssetTransfer(
    intc_2 // axfer
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/digitalmarketplace/contract.py:61-66
    // # Perform the internal asset transfer for opting in
    // itxn.AssetTransfer(
    //     xfer_asset=self.asset_id,  # Asset to opt into
    //     asset_receiver=Global.current_application_address,  # Application receives the asset
    //     asset_amount=0,  # Zero tokens are sent, enabling opt-in
    // ).submit()
    itxn_submit
    retsub


// smart_contracts.digitalmarketplace.contract.Digitalmarketplace.set_price(unitary_price: uint64) -> void:
set_price:
    // smart_contracts/digitalmarketplace/contract.py:68-69
    // @arc4.abimethod
    // def set_price(self, unitary_price: UInt64) -> None:
    proto 1 0
    // smart_contracts/digitalmarketplace/contract.py:79-80
    // # Ensure only the creator can modify the price
    // assert Txn.sender == Global.creator_address
    txn Sender
    global CreatorAddress
    ==
    assert
    // smart_contracts/digitalmarketplace/contract.py:81-82
    // # Update the unit price
    // self.unitary_price = unitary_price
    bytec_1 // "unitary_price"
    frame_dig -1
    app_global_put
    retsub


// smart_contracts.digitalmarketplace.contract.Digitalmarketplace.buy(quantity: uint64, buyer_txn: uint64) -> void:
buy:
    // smart_contracts/digitalmarketplace/contract.py:84-85
    // @arc4.abimethod
    // def buy(self, quantity: UInt64, buyer_txn: gtxn.PaymentTransaction) -> None:
    proto 2 0
    // smart_contracts/digitalmarketplace/contract.py:99-100
    // # Ensure the unit price is greater than zero
    // assert self.unitary_price != UInt64(0)
    intc_0 // 0
    bytec_1 // "unitary_price"
    app_global_get_ex
    assert // check self.unitary_price exists
    assert
    // smart_contracts/digitalmarketplace/contract.py:102-103
    // # Ensure the sender of the payment matches the caller
    // assert buyer_txn.sender == Txn.sender
    frame_dig -1
    gtxns Sender
    txn Sender
    ==
    assert
    // smart_contracts/digitalmarketplace/contract.py:105-106
    // # Ensure the payment is directed to the smart contract
    // assert buyer_txn.receiver == Global.current_application_address
    frame_dig -1
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    assert
    // smart_contracts/digitalmarketplace/contract.py:108-109
    // # Ensure the payment amount matches the expected price
    // assert buyer_txn.amount == self.unitary_price * quantity
    frame_dig -1
    gtxns Amount
    intc_0 // 0
    bytec_1 // "unitary_price"
    app_global_get_ex
    assert // check self.unitary_price exists
    frame_dig -2
    *
    ==
    assert
    // smart_contracts/digitalmarketplace/contract.py:111-116
    // # Perform the internal transaction to transfer assets
    // itxn.AssetTransfer(
    //     xfer_asset=self.asset_id,  # Asset to transfer
    //     asset_receiver=Txn.sender,  # Receiver of the asset
    //     asset_amount=quantity,  # Quantity to transfer
    // ).submit()
    itxn_begin
    // smart_contracts/digitalmarketplace/contract.py:113
    // xfer_asset=self.asset_id,  # Asset to transfer
    intc_0 // 0
    bytec_0 // "asset_id"
    app_global_get_ex
    assert // check self.asset_id exists
    // smart_contracts/digitalmarketplace/contract.py:114
    // asset_receiver=Txn.sender,  # Receiver of the asset
    txn Sender
    frame_dig -2
    itxn_field AssetAmount
    itxn_field AssetReceiver
    itxn_field XferAsset
    // smart_contracts/digitalmarketplace/contract.py:111-112
    // # Perform the internal transaction to transfer assets
    // itxn.AssetTransfer(
    intc_2 // axfer
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/digitalmarketplace/contract.py:111-116
    // # Perform the internal transaction to transfer assets
    // itxn.AssetTransfer(
    //     xfer_asset=self.asset_id,  # Asset to transfer
    //     asset_receiver=Txn.sender,  # Receiver of the asset
    //     asset_amount=quantity,  # Quantity to transfer
    // ).submit()
    itxn_submit
    retsub


// smart_contracts.digitalmarketplace.contract.Digitalmarketplace.delete_application() -> void:
delete_application:
    // smart_contracts/digitalmarketplace/contract.py:118-119
    // @arc4.abimethod(allow_actions=["DeleteApplication"])
    // def delete_application(self) -> None:
    proto 0 0
    // smart_contracts/digitalmarketplace/contract.py:128-129
    // # Ensure only the creator can delete the application
    // assert Txn.sender == Global.creator_address
    txn Sender
    global CreatorAddress
    ==
    assert
    // smart_contracts/digitalmarketplace/contract.py:131-137
    // # Transfer remaining assets to the creator
    // itxn.AssetTransfer(
    //     xfer_asset=self.asset_id,  # Asset to transfer
    //     asset_receiver=Global.creator_address,  # Receiver is the creator
    //     asset_amount=0,  # Transfer zero to close interaction with the asset
    //     asset_close_to=Global.creator_address,  # Close asset interaction and send balance to the creator
    // ).submit()
    itxn_begin
    // smart_contracts/digitalmarketplace/contract.py:133
    // xfer_asset=self.asset_id,  # Asset to transfer
    intc_0 // 0
    bytec_0 // "asset_id"
    app_global_get_ex
    assert // check self.asset_id exists
    // smart_contracts/digitalmarketplace/contract.py:134
    // asset_receiver=Global.creator_address,  # Receiver is the creator
    global CreatorAddress
    // smart_contracts/digitalmarketplace/contract.py:136
    // asset_close_to=Global.creator_address,  # Close asset interaction and send balance to the creator
    dup
    itxn_field AssetCloseTo
    // smart_contracts/digitalmarketplace/contract.py:135
    // asset_amount=0,  # Transfer zero to close interaction with the asset
    intc_0 // 0
    itxn_field AssetAmount
    itxn_field AssetReceiver
    itxn_field XferAsset
    // smart_contracts/digitalmarketplace/contract.py:131-132
    // # Transfer remaining assets to the creator
    // itxn.AssetTransfer(
    intc_2 // axfer
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/digitalmarketplace/contract.py:131-137
    // # Transfer remaining assets to the creator
    // itxn.AssetTransfer(
    //     xfer_asset=self.asset_id,  # Asset to transfer
    //     asset_receiver=Global.creator_address,  # Receiver is the creator
    //     asset_amount=0,  # Transfer zero to close interaction with the asset
    //     asset_close_to=Global.creator_address,  # Close asset interaction and send balance to the creator
    // ).submit()
    itxn_submit
    // smart_contracts/digitalmarketplace/contract.py:139-144
    // # Transfer remaining Algo balance to the creator
    // itxn.Payment(
    //     receiver=Global.creator_address,  # Receiver is the creator
    //     amount=0,  # Transfer zero Algo
    //     close_remainder_to=Global.creator_address,  # Send remaining balance to the creator
    // ).submit()
    itxn_begin
    // smart_contracts/digitalmarketplace/contract.py:141
    // receiver=Global.creator_address,  # Receiver is the creator
    global CreatorAddress
    // smart_contracts/digitalmarketplace/contract.py:143
    // close_remainder_to=Global.creator_address,  # Send remaining balance to the creator
    dup
    itxn_field CloseRemainderTo
    // smart_contracts/digitalmarketplace/contract.py:142
    // amount=0,  # Transfer zero Algo
    intc_0 // 0
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/digitalmarketplace/contract.py:139-140
    // # Transfer remaining Algo balance to the creator
    // itxn.Payment(
    intc_1 // pay
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/digitalmarketplace/contract.py:139-144
    // # Transfer remaining Algo balance to the creator
    // itxn.Payment(
    //     receiver=Global.creator_address,  # Receiver is the creator
    //     amount=0,  # Transfer zero Algo
    //     close_remainder_to=Global.creator_address,  # Send remaining balance to the creator
    // ).submit()
    itxn_submit
    retsub
